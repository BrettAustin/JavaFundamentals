import java.util.*;/** * A class of stacks whose entries are stored in a chain of nodes. *  * @author Frank M. Carrano * @author Timothy M. Henry * @version 5.0 */public final class LinkedStack<T> implements StackInterface<T> {		private Node topNode; // References the first node in the chain		public LinkedStack() {		topNode = null;	} 	public void push(T newEntry) {		Node newNode = new Node(newEntry, topNode);		topNode = newNode;		//    topNode = new Node(newEntry, topNode); // Alternate code	} 	public T peek() {		if (isEmpty())			throw new EmptyStackException();		else			return topNode.getData();	} // end peek	public T pop() {		T top = peek(); // Might throw EmptyStackException		topNode = topNode.getNextNode();		return top;	} 	public boolean isEmpty() {		return topNode == null;	} 	public void clear() {		topNode = null; 	} 	@Override	public String toString() {		String s = "";		Node current = topNode;		while (current != null) {			s = current.data + " " + s;			current = current.next;		}		return s;	}	public boolean priorityPush(T element) {		if(this.isEmpty()){//empty stack? Just push it			this.push(element);			return false;		}		Node newNode = new Node(element);		Node currentNode = topNode;		int nodePosition = 1;		do{			if(currentNode.data.equals(element)){				if(currentNode.next==null&&nodePosition==1){ //singleton match - just leave it					return true;				} else if(nodePosition==1){ //already at the top					return true;				}else{					push(removeItem(nodePosition));					return true;				}			} else{				currentNode = currentNode.next;				nodePosition++;			}		}while(currentNode!=null);		this.push(element);		return false;	}	private T removeItem(int location){		T result = null;		Node nodeToRemove = topNode;		Node previousNode = topNode;		for(int i = 1; i<location;i++){			nodeToRemove = nodeToRemove.next;		}		for(int i = 1; i<location-1;i++){			previousNode = previousNode.next;		}		result = nodeToRemove.data;		previousNode.next = nodeToRemove.next;		return result;	}	public T peekNext() {		if (isEmpty() //empty list? return false				||topNode.getData()==null //first node null? return false				|| topNode.getNextNode().data==null) //next node null? return false			return null;		else{			return topNode.getNextNode().data;		}	}		private class Node {		private T data; 		private Node next; 		private Node(T dataPortion) {			this(dataPortion, null);		} 		private Node(T dataPortion, Node linkPortion) {			data = dataPortion;			next = linkPortion;		}		private T getData() {			return data;		}		private void setData(T newData) {			data = newData;		}		private Node getNextNode() {			return next;		} 		private void setNextNode(Node nextNode) {			next = nextNode;		} 	} } 